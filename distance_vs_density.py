import scipy as sc
from scipy import stats
import numpy as np
import pandas as pd
from scipy.integrate import odeint
import matplotlib.pyplot as plt
import sys
import os

# PARAMETERS

#Parameters for the simulation
runs   = 100            # How many times we run the simulation
J      = 5               # Number of food sources (aka, number of trails to food sources)
N      = 10000           # Total number of ants

#Parameters from the equation, accessed by name
p    = {
"alpha"  : 0.75,            # Per capita rate of spontaneous discoveries
"s"      : 3.5,             # Per capita rate of ant leaving trail per distance
"gamma1" : 0.2,             # Range of foraging scouts
"gamma2" : 0.021,           # Range of recruitment activity
"gamma3" : 0.021,           # Range of influence of pheromone
"K"      : 1,               # Inertial effects that may affect pheromones
"n1"     : 20,              # Individual ant's contribution to rate of recruitment (orig. eta1)
"n2"     : 20               # Pheromone strength of trail (originally eta2)       
        }

Qmin = 0
Qmax = 20
Dmin = 0
Dmax = 60

betaB  = np.zeros(J)     # How much each ant contributes to recruitment to a trail
betaS  = np.zeros(J)     # Relationship btwn pheromone strength of a trail & its quality

# TIME

start = 0.0
stop  = 50.0            
step  = 0.005
tspan = np.arange(start, stop+step, step)

# INITIAL CONDITIONS

x0 = np.zeros(J)         # We start with no ants on any of the trails

# SYSTEM OF EQUATIONS

def dx_dt(x,t,Q,D,betaB,betaS):
        """
        Creates a list of J equations describing the number of ants
        on each of the J trails. (Eqn i corresponds to food source i)
        """
        system = np.zeros(J)
        system = (p["alpha"]* np.exp(-p["gamma1"]*D) + (p["gamma2"]/D)*betaB*x)*(N-sum(x)) - (p["s"]*D*x)/(p["K"]+ (p["gamma3"]/D)*betaS*x)
        return system


# RUNS AND MODEL OUTPUT


def simulation():

    final_time = np.zeros([runs, J])
    weight_avg_D = np.zeros(runs) # Sum of (# of ants on a trail * its distance)/(total number of trails)
    for w in range(runs):
        print(f"Run {w} of {runs} is running.\r", end="")
        Q = np.random.uniform(Qmin, Qmax, J)         #Choose each trail's quality from uniform dist
        D = np.random.uniform(Dmin, Dmax, J)         #Choose each trail's distance from uniform dist

        betaB = p["n1"] * Q
        betaS = p["n2"] * Q

        xs = odeint(dx_dt, x0, tspan, args=(Q,D,betaB,betaS)) #Solves the system. Columns: trail, Rows: time step
        final_time[w,:] = xs[-1,:]
        weight_avg_D[w] = sum((final_time[w,:] * D)/N)

    return weight_avg_D

def plot_fit(b, weight_avg):
    """
    plot fit takes in the list of weighted averages, plots a histogram of their distribution,
        and then plots the fitted distribution calculated by get_fit over them, mostly used for
        sanity-checking.
    """
    # Make our plot
    plt.rcParams['text.usetex'] = True                      #Comment out this line if you don't want to render latex.
    fig, ax = plt.subplots(figsize=(6,4), tight_layout=True)

    # Plot the normalized average weight histogram
    counts, bins = np.histogram(weight_avg)
    ax.stairs(100*counts/((bins[1]-bins[0])*sum(counts)), bins)

    # Plot the fitted distribution on top
    x_fitted = np.linspace(np.min(bins), np.max(bins), 100)
    y_fitted = 100 * (1/b) * np.exp((-1/b) * x_fitted) 
    ax.plot(x_fitted, y_fitted)

    ax.set_xlabel("Weighted Average of Distance to Food Source")
    ax.set_ylabel('$10^{-2}$ Density')
    plt.show()

def get_fit(weight_avg):
    """
    get_fit takes in a list of weighted averages generated by simulation and returns lambda,
        which is the parameter of an exponential distribution
    """
    b = stats.expon.fit(weight_avg, floc=0)[1]
    print(f"beta: {b}")
    return b

def plot_sweep_one(sweep_data):
    """ 
    plot_sweep_one takes in the output of sweep_one_fit and plots the values
    """
    # Make our plot
    #plt.rcParams['text.usetex'] = True                      #Comment out this line if you don't want to render latex.
    fig, ax = plt.subplots(figsize=(6,4), tight_layout=True)

    ax.plot(sweep_data[1], sweep_data[2])

    ax.set_xlabel(sweep_data[0])
    ax.set_ylabel("Beta")
    plt.show()


def sweep_one_fit(param, values):
    """ sweep_one_rtakes in the name of a parameter param string (ex: "alpha") and a list of the values
        to run a sweep on.
        Returns two arrays, the first containing the values and the second the resulting b value.
    """
    b_list = []
    for val in values:
        p[param] = val
        b_list.append(get_fit(simulation()))
    return param, values, b_list


def sweep_two_fit(param1, param2, values1, values2):
    index = values1
    columns = values2
    df = pd.DataFrame(0, index = index, columns = columns)
    for val1 in values1:
        for val2 in values2:
             p[param1] = val1
             p[param2] = val2
             df.at[val1,val2] = get_fit(simulation())
    #print(df)
    return df, param1, param2
    

def plot_sweep_two(sweepdata):
    """ 
    plot_sweep_two takes in the output of sweep_one_fit and plots the values
    """
    #print(sweepdata)
    fig, ax = plt.subplots(figsize=(6,4), tight_layout=True)
   # Displaying dataframe as an heatmap
   # with diverging colourmap as RdYlBu
    plt.imshow(sweepdata[0], cmap ="RdYlBu")
  
    # Displaying a color bar to understand
    # which color represents which range of data
    plt.colorbar()
  
    # Assigning labels of x-axis 
    # according to dataframe
    plt.xticks(range(len(sweepdata[0])), sweepdata[0].index)
  
    # Assigning labels of y-axis 
    # according to dataframe
    plt.yticks(range(len(sweepdata[0])), sweepdata[0].columns)

    ax.set_xlabel(sweepdata[1])
    ax.set_ylabel(sweepdata[2])
  
    # Displaying the figure
    plt.show()

#sim = simulation()
#plot_fit(get_fit(sim), sim)
# plot_sweep_one(sweep_one_fit("gamma2", [5.8e-7, 2.96e-6, 5.8e-6, 1.2e-5, 5.8e-5]))
plot_sweep_two(sweep_two_fit("gamma2", "n1", [5.8e-7, 2.96e-6, 5.8e-6, 1.2e-5, 5.8e-5], [0.12, 0.6, 1.2, 2.4, 12]))